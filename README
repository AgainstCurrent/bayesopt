--------------------------------------------------------------------------
---------                    LIBKRIGGING                         ---------
--------------------------------------------------------------------------


This is an efficient, C++ implementation of the Bayesian optimization
algorithm presented in the papers:

----
Ruben Martinez-Cantin, Nando de Freitas, Arnaud Doucet and Jose Castellanos.
Active Policy Learning for Robot Planning and Exploration under Uncertainty 
Robotics: Science and Systems. 2007

Ruben Martinez-Cantin, Nando de Freitas, Eric Brochu, Jose Castellanos and 
Arnaud Doucet (2009) A Bayesian Exploration-Exploitation Approach for 
Optimal Online Sensing and Planning with a Visually Guided Mobile Robot. 
Autonomous Robots - Special Issue on Robot Learning, Part B, 27(3):93-103.
----
 
Basically, it uses the active learning strategy to optimize an "arbitrary" 
funtion using few iterations.



****************
* 1 - INSTALL: *
****************

Libkrigging uses standard C/C++ code, standard libraries and it can
be compiled in different platforms using CMake.

Linux:
>> cmake . && make

Using ccmake . you will access a interface to select features such as
debug mode, which version of DIRECT to use (see below) and if you want
to use shared libraries or not.

If you have doxygen installed on your computer, you can compile the
documentation directly using cmake. 

You just need to download UseDoxygen.cmake
>> darcs get http://tobias.rautenkranz.ch/cmake/doxygen
>> cd doxygen
>> cmake . && make install

Then, in the directy where libkrigging is, use:

>> cmake . && make && make doc

The documentation will appear on the doc subdirectory.


Windows and Mac:
Not tested yet. But it should work. Feedback would be welcome.



**************************
*  1.1 -  DEPENDENCIES:  *
**************************

1.1.1 - BOOST:
**************
This code uses Boost libraries for matrix operations (uBlas) and random
number generation. They can be found in standard linux distributions or
it can be downloaded from (www.boost.org). Since they are pure template
libraries, they do not require compilation. Just make sure the headers are
on the include path.


1.1.2 - DIRECT:
***************

This library requires some other nonlinear optimization library 
(e.g.: DIRECT). 


a) Using Fortran DIRECT:

For completeness, it includes some Fortran 77 implementation of the
DIRECT-L algorithm by J. Gablonsky

J. M. Gablonsky and C. T. Kelley, "A locally-biased form of the DIRECT 
algorithm," J. Global Optimization, vol. 21 (1), p. 27-37 (2001). 

The original code can be downloaded from 
http://www4.ncsu.edu/~ctk/SOFTWARE/DIRECTv204.tar.gz
which includes some parallel processing functions that are not yet 
supported in libkrigging.

This code has only been tested using gcc and libgfortran.

b) Using NLOPT (default):

We recommend the use of NLOPT for the inner loop optimization. The latest
version can be downloaded from 

http://ab-initio.mit.edu/wiki/index.php/NLopt

NLOPT does not require external libraries and it should be compatible
with Windows and Mac (although not tested).



****************
* 2 - USAGE:   *
****************

Jointly with libkrigging, the test program krigtest will be compiled.
It can be used as an example of the interfaces that libkrigging provide.
There are two kind of interfaces.

2.1 - C functional usage
------------------------

This interface is fully functional from C and C++. It resembles the classic 
NLOPT interface, therefore, NLOPT manual can used as well. We just need to 
define a function pointer to the function that we need to evaluate. The 
function pointer must agree with the template provided in krigwpr.h

Note that the gradient has been included for future compatibility, although
in the current implementation, it is not used.


2.2 - C++ polymorphic usage
---------------------------

The second way to use the function is by creating an object that inherits 
from the Krigging object defined in krigging.hpp

Then, we just need to define the virtual function evaluateSample, which 
has interfaces both with C arrays and uBlas vectors. You can just redefine
your favorite interface.

Note that the checkReachability function has been included for future 
compatibility, although in the current implementation, it is not used.
